//! WebSocket message types
//!
//! Defines the message formats for WebSocket communication between
//! server and clients, following API conventions.

use crate::models::{OrderStatus, Side};
use serde::{Deserialize, Serialize};

/// Incoming WebSocket command from client
#[derive(Debug, Clone, Deserialize)]
#[serde(tag = "op")]
pub enum WsCommand {
    /// Subscribe to topics
    #[serde(rename = "subscribe")]
    Subscribe { args: Vec<String> },
    /// Unsubscribe from topics
    #[serde(rename = "unsubscribe")]
    Unsubscribe { args: Vec<String> },
}

/// WebSocket message sent to clients
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(tag = "type")]
pub enum WsMessage {
    /// Connection established
    #[serde(rename = "connected")]
    Connected { user_id: Option<u64> },
    /// Order status update
    #[serde(rename = "order.update")]
    OrderUpdate {
        order_id: u64,
        symbol: String,
        status: String, // SCREAMING_CASE: "NEW", "FILLED", etc.
        filled_qty: String,
        avg_price: Option<String>,
    },
    /// Trade notification (Private)
    #[serde(rename = "trade")]
    Trade {
        trade_id: u64,
        order_id: u64,
        symbol: String,
        side: String, // "BUY" or "SELL"
        price: String,
        qty: String,
        fee: String,       // Fee amount formatted
        fee_asset: String, // Asset in which fee was paid
        role: String,      // "MAKER" or "TAKER"
    },
    /// Public Trade Stream
    #[serde(rename = "public_trade")]
    PublicTrade {
        symbol: String,
        price: String,
        qty: String,
        quote_qty: String,
        time: i64,
        is_buyer_maker: bool,
    },
    /// Market Ticker Stream (24h Stats)
    #[serde(rename = "ticker")]
    Ticker {
        symbol: String,
        price_change: String,
        price_change_percent: String,
        last_price: String,
        high_price: String,
        low_price: String,
        volume: String,
        quote_volume: String,
        time: u64,
    },
    #[serde(rename = "depthUpdate")]
    Depth {
        #[serde(rename = "e")]
        event_type: String, // "depthUpdate"
        #[serde(rename = "E")]
        event_time: u64,
        #[serde(rename = "s")]
        symbol: String,
        #[serde(rename = "u")]
        update_id: u64,
        #[serde(rename = "b")]
        bids: Vec<(String, String)>, // [["price", "qty"], ...]
        #[serde(rename = "a")]
        asks: Vec<(String, String)>, // [["price", "qty"], ...]
    },
    /// Balance update
    #[serde(rename = "balance.update")]
    BalanceUpdate {
        asset: String,
        avail: String,
        frozen: String,
    },
    /// Pong response to ping
    #[serde(rename = "pong")]
    Pong,
    /// Subscription success
    #[serde(rename = "subscribed")]
    Subscribed { topics: Vec<String> },
    /// Unsubscription success
    #[serde(rename = "unsubscribed")]
    Unsubscribed { topics: Vec<String> },
    /// Error message
    #[serde(rename = "error")]
    Error { message: String },
}

/// Push event (internal queue message)
///
/// These events are generated by Settlement service and consumed
/// by WsService to send WebSocket messages to clients.
#[derive(Debug, Clone)]
pub enum PushEvent {
    /// Order status changed
    OrderUpdate {
        user_id: u64,
        order_id: u64,
        symbol_id: u32,
        status: OrderStatus,
        filled_qty: u64,
        avg_price: Option<u64>,
    },
    /// Trade executed
    Trade {
        user_id: u64,
        trade_id: u64,
        order_id: u64,
        symbol_id: u32,
        side: Side,
        price: u64,
        qty: u64,
        fee: u64,          // Fee amount (raw units)
        fee_asset_id: u32, // Asset ID for fee
        is_maker: bool,    // true=Maker, false=Taker
    },
    /// Balance changed
    BalanceUpdate {
        user_id: u64,
        asset_id: u32,
        avail: u64,
        frozen: u64,
    },
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_ws_message_order_update_serialization() {
        let msg = WsMessage::OrderUpdate {
            order_id: 123,
            symbol: "BTC_USDT".to_string(),
            status: "FILLED".to_string(),
            filled_qty: "0.100000".to_string(),
            avg_price: Some("85000.00".to_string()),
        };
        let json = serde_json::to_string(&msg).unwrap();

        // Verify type field uses dot notation
        assert!(json.contains(r#""type":"order.update""#));
        assert!(json.contains(r#""order_id":123"#));
        assert!(json.contains(r#""symbol":"BTC_USDT""#));
    }

    #[test]
    fn test_ws_message_trade_serialization() {
        let msg = WsMessage::Trade {
            trade_id: 456,
            order_id: 123,
            symbol: "BTC_USDT".to_string(),
            side: "Buy".to_string(),
            price: "85000.00".to_string(),
            qty: "0.100000".to_string(),
            fee: "0.000020".to_string(),
            fee_asset: "BTC".to_string(),
            role: "TAKER".to_string(),
        };
        let json = serde_json::to_string(&msg).unwrap();

        // trade type should not use dot notation
        assert!(json.contains(r#""type":"trade""#));
        assert!(json.contains(r#""trade_id":456"#));
    }

    #[test]
    fn test_ws_message_balance_update_serialization() {
        let msg = WsMessage::BalanceUpdate {
            asset: "USDT".to_string(),
            avail: "1000.0000".to_string(),
            frozen: "0.0000".to_string(),
        };
        let json = serde_json::to_string(&msg).unwrap();

        // Verify type field uses dot notation
        assert!(json.contains(r#""type":"balance.update""#));
        assert!(json.contains(r#""asset":"USDT""#));
    }

    #[test]
    fn test_ws_message_connected_serialization() {
        let msg = WsMessage::Connected {
            user_id: Some(1001),
        };
        let json = serde_json::to_string(&msg).unwrap();

        assert!(json.contains(r#""type":"connected""#));
        assert!(json.contains(r#""user_id":1001"#));
    }

    #[test]
    fn test_ws_message_pong_serialization() {
        let msg = WsMessage::Pong;
        let json = serde_json::to_string(&msg).unwrap();

        assert!(json.contains(r#""type":"pong""#));
    }

    #[test]
    fn test_ws_message_ticker_serialization() {
        let msg = WsMessage::Ticker {
            symbol: "BTC_USDT".to_string(),
            price_change: "2000.00".to_string(),
            price_change_percent: "5.00".to_string(),
            last_price: "42000.00".to_string(),
            high_price: "43000.00".to_string(),
            low_price: "40000.00".to_string(),
            volume: "100.50".to_string(),
            quote_volume: "4200000.00".to_string(),
            time: 1700000000,
        };
        let json = serde_json::to_string(&msg).unwrap();
        assert!(json.contains(r#""type":"ticker""#));
        assert!(json.contains(r#""symbol":"BTC_USDT""#));
        assert!(json.contains(r#""last_price":"42000.00""#));
    }
}
